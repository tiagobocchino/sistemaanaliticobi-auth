ðŸ“‹ PASSO A PASSO TÃ‰CNICO DETALHADO
ðŸ”§ FASE 1: PREPARAÃ‡ÃƒO DO AMBIENTE
bash
Copy
# 1. Criar estrutura de pastas
mkdir analytics-platform && cd analytics-platform

# 2. Criar ambiente virtual Python
python -m venv venv

# 3. Ativar ambiente
# Windows:
venv\Scripts\activate
# Mac/Linux:
source venv/bin/activate

# 4. Instalar dependÃªncias backend
pip install fastapi uvicorn python-dotenv pydantic-settings httpx asyncio
pip install supabase pandas numpy scikit-learn redis psutil
pip install agno openai groq

# 5. Criar estrutura de pastas
mkdir -p backend/src/{agents,analyses,auth,integrations,users,cache,monitoring,utils}
mkdir -p backend/database backend/tests backend/docs
mkdir -p frontend-rn/src/{screens,components,hooks,api,utils,context}

# 6. Inicializar frontend React Native
npx create-expo-app frontend-rn --template blank-typescript
cd frontend-rn
npm install @react-navigation/native @react-navigation/drawer
npm install react-native-screens react-native-safe-area-context
npm install @react-native-async-storage/async-storage
npm install axios react-native-chart-kit
npm install @expo/vector-icons
cd ..
ðŸ—ï¸ FASE 2: CONFIGURAÃ‡ÃƒO DO BACKEND
2.1 Arquivo de ConfiguraÃ§Ã£o Principal
Python
Copy
# backend/src/config.py
from pydantic_settings import BaseSettings
from typing import Optional

class Settings(BaseSettings):
    # Supabase
    SUPABASE_URL: str = "https://sua-url.supabase.co"
    SUPABASE_ANON_KEY: str = "seu-anon-key"
    SUPABASE_SERVICE_ROLE_KEY: str = "seu-service-role-key"
    
    # SeguranÃ§a
    SECRET_KEY: str = "sua-chave-secreta-super-segura"
    ENVIRONMENT: str = "development"
    
    # LLM Providers
    OLLAMA_BASE_URL: str = "http://localhost:11434/v1"
    OLLAMA_MODEL: str = "llama3.2"
    USE_OLLAMA: bool = True
    OPENAI_API_KEY: Optional[str] = None
    GROQ_API_KEY: Optional[str] = None
    
    # Redis
    REDIS_HOST: str = "localhost"
    REDIS_PORT: int = 6379
    REDIS_DB: int = 0
    
    # Performance
    CACHE_DEFAULT_TIMEOUT: int = 3600
    DEFAULT_PAGE_SIZE: int = 20
    MAX_PAGE_SIZE: int = 100
    
    class Config:
        env_file = ".env"

settings = Settings()
2.2 Cliente Supabase
Python
Copy
# backend/src/supabase_client.py
from supabase import create_client, Client
from .config import settings

class SupabaseClient:
    def __init__(self):
        self.client: Client = create_client(
            settings.SUPABASE_URL,
            settings.SUPABASE_SERVICE_ROLE_KEY
        )
    
    def get_client(self) -> Client:
        return self.client

supabase_client = SupabaseClient()
ðŸ” FASE 3: SISTEMA DE AUTENTICAÃ‡ÃƒO
3.1 Modelos de AutenticaÃ§Ã£o
Python
Copy
# backend/src/auth/models.py
from pydantic import BaseModel, EmailStr
from typing import Optional

class UserSignup(BaseModel):
    email: EmailStr
    password: str
    full_name: str

class UserSignin(BaseModel):
    email: EmailStr
    password: str

class UserResponse(BaseModel):
    id: str
    email: str
    full_name: str
    cargo_id: Optional[int]
    divisao_id: Optional[int]
    nivel_acesso: Optional[int]
3.2 ServiÃ§o de AutenticaÃ§Ã£o
Python
Copy
# backend/src/auth/service.py
from supabase import Client
from typing import Dict, Optional
from .models import UserSignup, UserSignin

class AuthService:
    def __init__(self, supabase_client: Client):
        self.client = supabase_client
    
    async def sign_up(self, user_data: UserSignup) -> Dict:
        """Registra novo usuÃ¡rio"""
        try:
            # Criar usuÃ¡rio no Supabase Auth
            auth_response = self.client.auth.sign_up({
                "email": user_data.email,
                "password": user_data.password
            })
            
            if auth_response.user:
                # Criar perfil no banco
                profile_data = {
                    "id": auth_response.user.id,
                    "email": user_data.email,
                    "full_name": user_data.full_name,
                    "created_at": datetime.now().isoformat()
                }
                
                self.client.table('usuarios').insert(profile_data).execute()
                
                return {
                    "user": auth_response.user,
                    "session": auth_response.session,
                    "message": "UsuÃ¡rio criado com sucesso"
                }
            
            raise Exception("Erro ao criar usuÃ¡rio")
            
        except Exception as e:
            raise Exception(f"Erro no signup: {str(e)}")
    
    async def sign_in(self, credentials: UserSignin) -> Dict:
        """Realiza login"""
        try:
            response = self.client.auth.sign_in_with_password({
                "email": credentials.email,
                "password": credentials.password
            })
            
            return {
                "access_token": response.session.access_token,
                "refresh_token": response.session.refresh_token,
                "user": response.user
            }
            
        except Exception as e:
            raise Exception(f"Erro no login: {str(e)}")

# InstÃ¢ncia global
auth_service = AuthService(supabase_client.get_client())
ðŸ“Š FASE 4: SISTEMA DE ANÃLISES
4.1 Modelos de AnÃ¡lises
Python
Copy
# backend/src/analyses/models.py
from pydantic import BaseModel
from typing import Optional, List
from datetime import datetime

class Analysis(BaseModel):
    id: Optional[int] = None
    nome: str
    descricao: str
    tipo: str  # 'powerbi', 'python', 'tableau'
    embed_url: Optional[str] = None
    divisao_restrita_id: Optional[int] = None
    publico: bool = True
    ativo: bool = True
    created_at: Optional[datetime] = None

class AnalysisResponse(Analysis):
    id: int
    created_at: datetime
4.2 ServiÃ§o de AnÃ¡lises
Python
Copy
# backend/src/analyses/service.py
from typing import List, Optional, Dict
from .models import Analysis, AnalysisResponse

class AnalysisService:
    def __init__(self, supabase_client):
        self.client = supabase_client
    
    async def get_accessible_analyses(self, user_id: str, nivel_acesso: int, divisao_id: Optional[int]) -> List[Dict]:
        """Retorna anÃ¡lises acessÃ­veis ao usuÃ¡rio"""
        
        query = self.client.table('analyses').select('*')
        
        # Aplicar filtros baseado no nÃ­vel de acesso
        if nivel_acesso < 4:  # NÃ£o Ã© admin
            if divisao_id:
                query = query.or_(f'publico.eq.true,divisao_restrita_id.eq.{divisao_id}')
            else:
                query = query.eq('publico', True)
        
        result = query.eq('ativo', True).execute()
        return result.data if result.data else []
    
    async def create_analysis(self, analysis_data: Analysis) -> AnalysisResponse:
        """Cria nova anÃ¡lise"""
        data = analysis_data.dict(exclude_none=True)
        data['created_at'] = datetime.now().isoformat()
        
        result = self.client.table('analyses').insert(data).execute()
        
        if result.data:
            return AnalysisResponse(**result.data[0])
        
        raise Exception("Erro ao criar anÃ¡lise")

# InstÃ¢ncia global
analysis_service = AnalysisService(supabase_client.get_client())
ðŸ¤– FASE 5: AGENTE IA
5.1 Agente Principal com Tools
Python
Copy
# backend/src/agents/core.py
from typing import Dict, List, Optional, Any
from datetime import datetime
import json

class AnalyticsAgent:
    def __init__(self, model_config: Dict[str, Any]):
        self.model_config = model_config
        self.tools = {
            "trend_analysis": self.analyze_trends,
            "compare_periods": self.compare_periods,
            "predict_sales": self.predict_sales,
            "find_opportunities": self.find_opportunities,
            "generate_chart": self.generate_chart
        }
        self.conversation_memory = []
    
    def analyze_trends(self, data: List[Dict]) -> Dict:
        """AnÃ¡lise de tendÃªncias temporais"""
        try:
            # Processar dados
            df = pd.DataFrame(data)
            df['data'] = pd.to_datetime(df['data'])
            
            # Calcular tendÃªncias
            values = df['valor'].values
            trend = np.polyfit(range(len(values)), values, 1)[0]
            
            # Gerar insights
            insights = []
            if trend > 0:
                growth_rate = (trend / np.mean(values)) * 100
                insights.append(f"ðŸ“ˆ TendÃªncia de crescimento: {growth_rate:.1f}% por perÃ­odo")
            else:
                decline_rate = abs((trend / np.mean(values)) * 100)
                insights.append(f"ðŸ“‰ TendÃªncia de queda: {decline_rate:.1f}% por perÃ­odo")
            
            return {
                "status": "success",
                "tendencia": "crescente" if trend > 0 else "decrescente",
                "inclinacao": float(trend),
                "media": float(np.mean(values)),
                "insights": insights,
                "dados": data
            }
            
        except Exception as e:
            return {
                "status": "error",
                "message": f"Erro na anÃ¡lise de tendÃªncias: {str(e)}"
            }

    def process_message(self, message: str, user_context: Dict) -> Dict:
        """Processa mensagem do usuÃ¡rio"""
        
        # Detectar intenÃ§Ã£o
        intent = self._detect_intent(message)
        
        # Selecionar tool apropriada
        if intent == "trend_analysis":
            result = self.analyze_trends(user_context.get("data", []))
            response = self._format_trend_response(result)
            tools_used = ["trend_analysis"]
        elif intent == "comparison":
            result = self.compare_periods(user_context.get("data", []))
            response = self._format_comparison_response(result)
            tools_used = ["compare_periods"]
        else:
            response = self._format_general_response(message)
            tools_used = []
        
        return {
            "response": response,
            "tools_used": tools_used,
            "confidence": 85.0
        }
ðŸ“± FASE 6: FRONTEND REACT NATIVE
6.1 ConfiguraÃ§Ã£o da API
TypeScript
Copy
// frontend-rn/src/api/client.ts
import axios from 'axios';
import AsyncStorage from '@react-native-async-storage/async-storage';

const API_BASE_URL = 'http://localhost:8000';

export const apiClient = axios.create({
  baseURL: API_BASE_URL,
  timeout: 30000,
});

// Interceptor para adicionar token
apiClient.interceptors.request.use(
  async (config) => {
    const token = await AsyncStorage.getItem('access_token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Interceptor para refresh token
apiClient.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;
    
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;
      
      try {
        const refreshToken = await AsyncStorage.getItem('refresh_token');
        const response = await apiClient.post('/auth/refresh', { refresh_token: refreshToken });
        
        await AsyncStorage.setItem('access_token', response.data.access_token);
        return apiClient(originalRequest);
      } catch (error) {
        await AsyncStorage.multiRemove(['access_token', 'refresh_token']);
        throw error;
      }
    }
    
    return Promise.reject(error);
  }
);
6.2 Hook de AutenticaÃ§Ã£o
TypeScript
Copy
// frontend-rn/src/hooks/useAuth.ts
import { useState, useEffect, createContext, useContext } from 'react';
import { apiClient } from '../api/client';
import AsyncStorage from '@react-native-async-storage/async-storage';

interface User {
  id: string;
  email: string;
  full_name: string;
  nivel_acesso: number;
  divisao_nome: string;
}

interface AuthContextType {
  user: User | null;
  loading: boolean;
  login: (email: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
}

const AuthContext = createContext<AuthContextType>({} as AuthContextType);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    checkAuth();
  }, []);

  const checkAuth = async () => {
    try {
      const token = await AsyncStorage.getItem('access_token');
      if (token) {
        const response = await apiClient.get('/auth/me');
        setUser(response.data.user);
      }
    } catch (error) {
      await AsyncStorage.multiRemove(['access_token', 'refresh_token']);
    } finally {
      setLoading(false);
    }
  };

  const login = async (email: string, password: string) => {
    try {
      const response = await apiClient.post('/auth/signin', { email, password });
      
      await AsyncStorage.setItem('access_token', response.data.access_token);
      await AsyncStorage.setItem('refresh_token', response.data.refresh_token);
      
      setUser(response.data.user);
    } catch (error) {
      throw error;
    }
  };

  const logout = async () => {
    try {
      await apiClient.post('/auth/signout');
      await AsyncStorage.multiRemove(['access_token', 'refresh_token']);
      setUser(null);
    } catch (error) {
      console.error('Erro no logout:', error);
    }
  };

  return (
    <AuthContext.Provider value={{ user, loading, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth deve ser usado dentro de AuthProvider');
  }
  return context;
};
ðŸ—„ï¸ FASE 7: BANCO DE DADOS
7.1 SQL de ConfiguraÃ§Ã£o do Banco
sql
Copy
-- database/setup.sql
-- CriaÃ§Ã£o de tabelas principais

CREATE TABLE IF NOT EXISTS public.cargos (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(50) UNIQUE NOT NULL,
    nivel_acesso INTEGER NOT NULL CHECK (nivel_acesso BETWEEN 1 AND 5),
    ativo BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS public.divisoes (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(50) UNIQUE NOT NULL,
    codigo VARCHAR(10) UNIQUE NOT NULL,
    ativo BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS public.usuarios (
    id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    full_name VARCHAR(255) NOT NULL,
    cargo_id INTEGER REFERENCES public.cargos(id),
    divisao_id INTEGER REFERENCES public.divisoes(id),
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS public.analyses (
    id SERIAL PRIMARY KEY,
    nome VARCHAR(255) NOT NULL,
    descricao TEXT,
    tipo VARCHAR(50) NOT NULL CHECK (tipo IN ('powerbi', 'python', 'tableau')),
    embed_url TEXT,
    divisao_restrita_id INTEGER REFERENCES public.divisoes(id),
    publico BOOLEAN DEFAULT true,
    ativo BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Inserir dados iniciais
INSERT INTO public.cargos (nome, nivel_acesso) VALUES
    ('Analista', 1),
    ('Coordenador', 2),
    ('Gerente', 3),
    ('Diretor', 4),
    ('Master', 5);

INSERT INTO public.divisoes (nome, codigo) VALUES
    ('Comercial', 'COM'),
    ('Financeiro', 'FIN'),
    ('Tecnologia', 'TI'),
    ('RH', 'RH'),
    ('Marketing', 'MK');

-- Criar trigger para sincronizaÃ§Ã£o
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.usuarios (id, email, full_name)
    VALUES (NEW.id, NEW.email, NEW.raw_user_meta_data->>'full_name');
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW EXECUTE FUNCTION handle_new_user();
ðŸš€ FASE 8: IMPLEMENTAÃ‡ÃƒO FINAL
8.1 Arquivo Main
Python
Copy
# backend/main.py
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager
import logging

from src.agents.routes import router as agents_router
from src.analyses.routes import router as analyses_router
from src.auth.routes import router as auth_router
from src.users.routes import router as users_router
from src.monitoring.routes import router as monitoring_router
from src.monitoring.system_monitor import system_monitor

# Configurar logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    logger.info("ðŸš€ Iniciando Analytics Platform...")
    
    # Iniciar monitoramento em background
    asyncio.create_task(background_monitoring())
    
    yield
    
    # Shutdown
    logger.info("ðŸ›‘ Desligando Analytics Platform...")

app = FastAPI(
    title="Analytics Platform",
    description="Plataforma de anÃ¡lises empresariais com IA",
    version="1.0.0",
    lifespan=lifespan
)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:8085", "http://localhost:19006"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Rotas
app.include_router(auth_router, prefix="/api")
app.include_router(analyses_router, prefix="/api")
app.include_router(agents_router, prefix="/api")
app.include_router(users_router, prefix="/api")
app.include_router(monitoring_router, prefix="/api")

@app.get("/")
async def root():
    return {
        "message": "ðŸš€ Analytics Platform",
        "version": "1.0.0",
        "docs": "/docs",
        "health": "/health"
    }

@app.get("/health")
async def health_check():
    return {
        "status": "healthy",
        "timestamp": datetime.now().isoformat(),
        "uptime": "running"
    }

async def background_monitoring():
    """Monitoramento em background"""
    while True:
        try:
            await system_monitor.collect_system_metrics()
            await asyncio.sleep(60)  # Coletar a cada minuto
        except Exception as e:
            logger.error(f"Erro no monitoramento: {e}")
            await asyncio.sleep(30)

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
### RAG (recuperacao de contexto)
- Indice BM25 local em `data/rag_index.json` (sem dependencias externas).
- Gerar/atualizar: `python scripts/build_rag_index.py`.
- Variaveis: `RAG_ENABLED=true|false`, `RAG_TOP_K` (padrao 3), `RAG_INDEX_PATH` (padrao data/rag_index.json).
- Respostas do agente podem incluir `rag_sources` (debug) mostrando as fontes do RAG.
